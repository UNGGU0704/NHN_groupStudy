= Reading 7 : Designing Specifications
Reference by <http://web.mit.edu/6.005/www/fa15/classes/07-designing-specs/>
v1.0, 2023-09-24

== objectives
* 부정확한 sepc을 이해, 불확실성을 식별하고 평가
* declaractive spec과 operational spec의 차이를 이해하고 선언적 규격을 작성할수있다.
* precondition, postcondition그리고 spec의 strength를 이해하고 spec strength를 비교할 수 있다.
* 일관되고 유용한 규격을 작성하는 능력을 갖춘다.

== Deterministic vs underdetermined specs

[source, java]
----
// First
static int find(int[] arr, int val) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == val) return i;
    }
    return arr.length;
}

// Last
static int find(int[] arr, int val) {
    for (int i = arr.length - 1 ; i >= 0; i--) {
        if (arr[i] == val) return i;
    }
    return -1;
}
----

* ``First``와``last``라는 첨자는 실제 Java구문 아님 주의

* 다음은 find에 대한 하나의 specification
[source, java]
----
static int findExactlyOne(int[] arr, int val)
  requires: val occurs exactly once in arr
  effects:  returns index i such that arr[i] = val
----
* 이 specification은 ``deterministic``입니다. precondtion을 충족하는 상태가 주어지면 결과가 완전히 결정됩니다.
* 하나의 반환 값과 최종 상태만 도출됨
* 하나이상의 유효한 출력이 있는 유효한 입력은 없습니다.

** 두 find메서드는 모두 specification을 만족하므로 클라이언트가 의존하는 specification이라면 두 구현 모두 동등하고 대체 가능합니다.

다음은 약간 다른 명세입니다.

[source, java]
----
static int findOneOrMore,AnyIndex(int[] arr, int val)
  requires: val occurs in arr
  effects:  returns index i such that arr[i] = val
----

* 이 명세는 ``deterministic``하지 않습니다.
* 이 명세는 동일한 입력에 대해 여러 유효한 출력을 합니다.

* ``underdetermined``는 일반적으로 사용되는 ``nondeterministic(비결정론적)``의미와 다르다.
** ``underdetermined``: 명세가 하나의 입력에 대해 오직 하나의 출력만 정의 하는것이 아니라 +
구현자가 여러가지 가능한 출력중 하나를 선택할수 있는 sepcification을 의미

* 예를 들어, 배열에서 특정 값을 찾는 명세를 다시 보면(find) 만약 명세가  ``val``이 배열 안에 정확히 한번 나타난다. 라고하면 그결과는 항상 하나로 결정됩니다.
* 그러나 다른 명세인 ``val``이 배열안에 적어도 한 번 나타난다 라고 하면 ``val``이 여러번 나타날 경우 어떤 인덱스가 반환될지 정해져 있지 않습니다. 이런 경우 어떤 구현자는 처음부터 검색을 시작하고 누구는 뒤에서부터 검색을 시작한다.

* 이렇게 ``underdetermined``명세는 구현자가 선택할 수 있는 여러가지 방법을 허용한다. 대부분의 경우 underdetermined명세는 구현이 deterministic 방식으로 선택되지만 , 구현자가 구현을 선택하는 방법을 나타낸다.

== Declarative vs operational specs

* 프로그램 명세에는 두가지 종류가있다

* **operational specifications**(운영적 명세): 메소드가 수행하는 단계를 설명하고 구현 세부 사항을 노출할 수 있다.

** ``pseudocode``은 operational specification의 한 예입니다.

*** ``pseudocode(의사 코드)``? 프로그램을 작성할 때 각 모듈이 작동하는 논리를 표현하는 언어이며, +
특정 프로그래밍 언어의 문법에 따라 쓰인 것이 아니라 일반적인 언어로 코드를 흉내 내어 알고리즘을 써놓은 코드

* **declarative specifications**(선언적 명세): 중간 단계의 세부 내용을 제공하지 않습니다. 대신 최종 결과물의 특성과 초기 상태와의 관련성만 제공하며, 이러한 명세는 더 짧고 이해하기 쉽습니다.

* **선언적 명세**를 선호합니다. 더 짧고 이해하기 쉬우며, 가장 중요한 것은 클라이언트가 구현 세부 사항에 의존하지 않도록 하므로 구현이 변경될 때 문제가 발생할 가능성이 줄어듭니다.

** 예를들어 find메서드의 두가지 구현을 모두 허용할때 명세는 메서드가 "val을 찾을 때까지 배열이 내려간다"는 명세 대신에 **``어떤 결과가 반환되어야 하는지 명시하는 것이 더 좋다``**. 그렇게 하면 클라이언트가 구현 세부 사항에 의존하지 않게 되어서 구현이 변경되어도 문제가 발생하지 않습니다.

* 프로그래머가 때로는 명세 주석을 유지보수자에게 구현을 설명하는데 사용하기 때문에 운영 명세로 빠지는 경우가 있다 ``Don't do this``
** 이러한 설명은 메서드 내부의 주석을 이용하자

* 선언적 명세를 다양하게 표현할수있다 다음과 같다

[source, java]
----
static boolean startsWith(String str, String prefix)
 effects: returns true if and only if there exists String suffix
            such that prefix + suffix == str

static boolean startsWith(String str, String prefix)
 effects: returns true if and only if there exists integer i
            such that str.substring(0, i) == prefix

static boolean startsWith(String str, String prefix)
 effects: returns true if the first prefix.length() characters of str
            are the characters of prefix, false otherwise
----

* 명세에 따라 선언적으로 표현할 수 있는 여러가지 방법이 있으며, 이러한 방법중 클라이언트와 유지보수자를 위해 가장 명확한 방법을 선택해야한다.

== Stronger vs Weaker specs

* 두가지 명세의 행동을 비교하여 기존 명세를 새 명세로 대체할 때 어떻게 결정하는가?
* 현재 명세에 의존하는 클라이언트가 있을때 어떻게 두 명세의 행동을 비교하여 이전 명세를 새 명세로 안전하게 교체할 수 있는가?

* s2명세가 s1명세보다 강하다는것은 다음과 같다.
** s2의 precondition < = s1의 precondition
** s2의 postcondition >= s1의 postcondition(s1의 precondition 조건을 만족하는 상태에서)

* 이 경우 s2를 만족하는 구현은 s1을 만족시키기 위해 사용할 수 있으며 프로그램에서 s1을 s2로 대체하는 것이 안전하다

* precondition을 **"약화할 수 있다"**는 것은 클라이언트에게 요구되는 조건을 더 관대하게 만들 수 있다는 의미. 이것은 클라이언트에게 덜 제한적인 사용 방법을 허용한다는 것을 의미합니다. +
즉 클라이언트가 더 쉽게 메서드를 사용할 수 있습니다.

* postcondition을 **"강화할 수 있다"**는 것은 메서드가 더 많은 약속을 한다는 의미이다. 이것은 메서드가 더 많은 것을 보장하거나 더 많은 일을 처리한다는 것을 의미합니다.

* 즉 이러한 규칙은 메서드의 명세를 더 관대하거나 더 엄격하게 만들 수 있습니다.

예를들어 다음과 같은 find 메서드의 명세:

[source, java]
----
static int findExactlyOne(int[] a, int val)
  requires: val occurs exactly once in a
  effects:  returns index i such that a[i] = val

다음과 같이 더 약한 precondition을 가진 명세로 대체 가능

static int findOneOrMore,AnyIndex(int[] a, int val)
  requires: val occurs at least once in a
  effects:  returns index i such that a[i] = val

그리고 이것은 다음과 같이 더 강한 postcondition 명세로 대체 가능

static int findOneOrMore,FirstIndex(int[] a, int val)
  requires: val occurs at least once in a
  effects:  returns lowest index i such that a[i] = val

또 다른 명세인 다음 명세는 나중에 연습에서 다룬다.

static int findCanBeMissing(int[] a, int val)
  requires: nothing
  effects:  returns index i such that a[i] = val,
              or -1 if no such i


----

* 즉 명세 간의 강도를 비교하여 더 강한 명세로 대체할 수 있는지 여부를 결정하는 규칙에 대한 설명이다.

== Diagramming specifications

* ``findFirst``와 ``findLast``를 다이어그램화 합니다. 다시 코드를 확인하면 두 메서드는 spec이 아닌 메서드 구현입니다. 그래서 다이어그램에서 "점" 으로 나타냅니다.

image::image/reading7/i1.png[]

* 그 다음 명세는 가능한 모든 구현 공간에서 일부 영역을 정의

* 예를 들어, findFirst와 findLast는 모두 findOneOrMore,AnyIndex 명세를 만족시키므로 해당 명세에 의해 정의된 영역 내에 위치합니다.

image::image/reading7/i2.png[]

*** 명세가 정의한 영역은 클라이언트의 관점에서 생각할 수 있으며, 명세는 구현자와 클라이언트 간의 상호 작용을 제어하는 역할

*** 구현자는 명세 내에서 자유롭게 코드를 변경할 수 있어야한다.

*** 클라이언트는 어떤 구현을 받게 될지 미리 알수 없다, 하지만 명세를 따르고, 구현을 사용하는 방식을 변경할 수 있는 자유를 가지며, 이로 인한 오작동을 걱정 안해도 된다.

* 비슷한 명세가 서로 어떻게 관련 되는가?(s1명세 에서 시작해 새로운 s2명세를 생성 했을 경우)

* s2가 s1보다 강하다면 우리 다이어그램엔 어떻게 나타날까?

*** **``strengthening the postcondition.``**: s2의 postcondition이 이제 s1의 postcondtioin보다 더 강한 경우는 s2는 더 강한 명세이다.

** 후결 조건을 강화한다는 것은 구현자에게 더욱 엄격한 결과물을 요구하는것을 의미
** 예를 들어 이전에 findOneOrMore,AnyIndex를 만족시키기 위해 어떤 인덱스 i를 반환했다면, 이제 findOneOrMore,FirstIndex 명세는 가장 낮은 인덱스 i를 요구하므로 해당 명세를 만족하는 구현은 findOneOrMore,AnyIndex 내에 있지만 findOneOrMore,FirstIndex 외부에 있을 것입니다.

** 하지만 findOneOrMore,FirstIndex를 만족하는데 findOneOrMore,AnyIndex를 만족하지 못하는 구현은 존재할 수 없습니다. 왜냐하면 모든 이러한 구현은 findOneOrMore,AnyIndex가 요구하는 것보다 더 강한 후결 조건을 충족하기 때문입니다. 즉, 후결 조건을 강화하면 명세가 더 엄격해지며, 이를 만족하는 구현은 더 제한적이 됩니다.

*** **``weaken the precondtion``**: s2가 s1보다 더 강한 명세가 됩니다.
** 이말은 구현이 이전에는 허용되지 않았던 입력을 처리해야 한다는 것을 의미합니다.
** 만약 구현이 이전에 그러한 입력에서 잘못된 동작을 보였다면, 우리는 그것을 이전에는 주목하지 않았을 수 있지만, 이제 그 부적절한 동작이 드러나게 됩니다. 즉, 사전 조건을 약화하면 명세가 덜 제한적이 되며 구현은 더 다양한 입력을 다루어야 합니다. 

*** 결론적으로 s2가 s1보다 강한 경우 다이어그램에서 s2는 더 작은 지역을 정의하며, 더 약한 명세는 더 큰 지역을 정의한다. 다른 명세는 서로 겹칠수도 겹치지 않을 수도 있다.

image::image/reading7/i3.png[]

== 좋은 명세의 설계(Designing good specifications)

* 명세의 형태에 대해서는 명백하고 간결하며 잘 구조화되어 있어야 하고 읽기 쉬워야 한다.

* 명세의 내용이 어려울때 유용한 지침 몇가지가 있다

=== 1. specification의 일관성

* 명세는 일관성이 있어야함.

[source, java]
----
static int sumFind(int[] a, int[] b, int val)
  effects: returns the sum of all indices in arrays a and b at which
             val appears
----

* 위 명세는 비일관적이며, 잘 설계되지 못한 프로시저이다.

* 인덱스를 찾는 메서드 , 인덱스를 합산하는 메서드 두 개의 별도 메서드를 사용하는게 낫다.

[source, java]
----
public static int LONG_WORD_LENGTH = 5;
public static String longestWord;

/**
 * Update longestWord to be the longest element of words, and print
 * the number of elements with length > LONG_WORD_LENGTH to the console.
 * @param words list to search for long words
 */
public static void countLongWords(List<String> words)
----

* 글로벌 변수의 오남용 및 반환 대신 출력을 사용하는 문제 외에도 명세에 일관성이 없다.
* 이 명세는 단어를 세는 작업과, 가장 긴 단어를 찾는 작업 두가지를 수행합니다.

* 두 가지 역할을 두 메서드로 분리하면 더욱 이해하기 쉬워지며, 재사용이 유용해짐

=== 2. The results of a call should be informative

* 아래 명세는 맵에 값을 넣는 메서드를 다루고있다.

[source, java]
----
static V put (Map<K,V> map, K key, V val)
  requires: val may be null, and map may contain null values
  effects:  inserts (key, val) into the mapping,
              overriding any existing mapping for key, and
              returns old value for key, unless none,
              in which case it returns null

----

* 명세는 결과가 정보를 제공해야 한다는 것. 이것은 메서드가 무엇을 수행했는지와 결과가 어떤 의미를 가지는지에 대한 정보를 반환해야 한다는 것을 의미

* 예를 들어, 이 명세에서는 맵에 값을 넣고 이전 값(만약 있으면)을 반환하는 메소드를 다룹니다. 그러나 이 명세의 문제는 이 메소드가 null 값을 다룰 수 있다는데, 동시에 null을 결과로 반환함으로써 문제를 일으킬 수 있다는 것입니다. 만약 null이 반환된다면, 이 메소드를 호출한 클라이언트는 해당 키가 이전에 맵에 없었는지, 아니면 해당 키가 null과 연결되었었는지를 알 수 없습니다. 이것은 결과가 정보를 제공하지 않는 경우입니다.

* 결과적으로, 이러한 명세는 사용하기 어려우며, 결과가 명확하지 않을수 있다. 명세를 개선하려면 결과가 더 유용한 정보를 제공하도록 설계해야함.

=== 3.The specification should be strong enough

* 메서드 명세가 충분히 강해야 한다.
* 메서드 명세는 클라이언트가 메서드를 사용할 때 기본적인 요구사항을 확실히 이해할 수 있도록 해야 한다. 특별한 경우에 대한 명세를 작성할 때는 그 경우가 메서드의 일반적인 유용성을 해치지 않도록 주의해야함.

** 예를 들어, 메소드가 잘못된 입력에 대한 예외를 던지면서 동시에 메소드의 동작을 설명하지 않는다면, 클라이언트는 메소드가 실제로 무엇을 수행했는지를 파악하기 어려울 수 있습니다. 따라서 메소드 명세는 특별한 경우에 대한 정보를 충분히 제공하여 클라이언트가 메소드를 안전하게 이해하고 활용할 수 있도록 해야 합니다.

[source, java]
----
static void addAll(List<T> list1, List<T> list2)
  effects: adds the elements of list2 to list1,
             unless it encounters a null element,
             at which point it throws a NullPointerException

----

* 이 명세에서는 NullPointerException이 발생할 때 클라이언트는 스스로 어떤 list2의 요소가 실제 list1에 추가되었는지를 판단해야합니다. +
따라서 명세를 개선하여 클라이언트가 결과를 더 확실히 이해하고 사용할 수 있도록 해야 합니다.

=== The specification should also be weak enough

[source, java]
----
static File open(String filename)
  effects: opens a file named filename
----

* 파일을 읽기용으로 여는 것인지 쓰기용 인지, 파일이 이미 존재하는 것인지 아니면 새로 생성되는 것인지에 대한 정보가 없다.

* 이 명세는 너무 강하다 왜냐하면 열수없는 권한의 파일일 경우인지를 보장할수 없기 때문(이러한 파일 시스템 문제 발생가능)

* 명세는 훨씬 약하게 적어야한다. 즉, 파일을 열려고 시도하고, 성공하면 파일에 대한 특정한 속성이 있다는 것을 설명해야합니다.

=== specification은 가능하다면 abstract types을 사용한다.

* 자바 컬렉션에서 ``list``나``set``같은 추상적인 개념과 ``ArrayList``나``HashSet``같은 구체적인 구현을 구분할수 있다.

* abstract types를 사용할것
HashMap이나 FileReader 대신 Map이나 Reader같은 인터페이스 유형을 사용하는 것을 의미

[source, java]
----
static ArrayList<T> reverse(ArrayList<T> list)
  effects: returns a new list which is the reversal of list, i.e.
             newList[i] == list[n-i-1]
             for all 0 <= i < n, where n = list.size()

----

* 명세는 클라이언트와 구현자가 ArrayList를 사용하도록 강제한다. ArrayList에 대한 구체적인 의존성이 없는 명세의 경우 더 추상적인 List를 기반으로 이 명세를 작성하는 것이 더 좋습니다.

=== Precondition or Postcondition?

* 메서드 설계시 precondition을 사용할지 여부와 고려사항

. precondition을 사용하는 이유는 메서드가 특정 조건을 확인하기 어렵거나 비용이 많이 들기 때문일 수 있다.

. 복잡한 preconditiond은 클라이언트에게 불편함을 초래하며, 메소드 호출 시 부적절한 상태로 호출하지 않도록 조심해야 합니다. 오류가 발생하면 복구하기 어려울 수 있습니다. 그래서 일반적으로 메소드 호출 시 잘못된 인수를 전달할 경우 예외를 던지는 것이 더 좋을 때가 많습니다.(``fail fast``가 원칙)

. precondition을 사용하면 클라이언트는 메서드를 호출하기 전에 조건을 검사하고, 메서드 내부에서 이러한 조건을 만족 시키려고 노력해야한다.

. precondition을 사용할지 여부를 결정할 때 고려해야하는 요소는 조건 확인 비용과 메서드의 범위이다. 로컬 클래ㅅ 내에서만 호출되는 경우 precondition을 사용하여 조건을 검사하고 해제할수 있지만. public method인 경우 예외를 던지는 것이 더 현명할 수있다.

. 메서드 설계시 precondition뿐만 아니라 postcondition도 고려하여 메서드가 안전하고 유용한 방식으로 동작하도록 해야함.

== About access control

. ``**공개 메서드(public methods)**``
** 다른 곳에서 자유롭게 사용하는 메서드
** 클래스가 외부로 제공하는 서비스
** 모든 메서드가 public이면 내부 메서드까지 외부에 노출되어 다른 곳에서 의존할수 있다.
** 내부 구현을 변경과 코드 유지 관리가 어려워 질수있다.

. ``**비공개 메서드(private methods)**``
** 클래스 내부에서만 사용되는 메서드로 외부에 노출되지 않음
** 클래스의 가시적인 인터페이스를 더 간결하고 명확하게 유지
** 클래스의 공개 인터페이스가 한가지 작업에 집중되고 코드를 이해하기 쉽게 만든다.

. ``**유지 보수(Maintenance for the Futer)**``
** 특히 내부 상태를 갖는 클래스의 경우, 내부 상태를 보호하고 외부에서 접근하지 못하도록 하는 것이 중요
** 버그를 방지하고 프로그램의 안정성을 높일 수 있다.

즉 메서드를 public 또는 private으로 만들때는 클래스의 의존성과 유지관리 기능성을 고려해야함. public mehtod는 다른 곳에서 사용 가능하며 클래스가 제공하는 서비스를 나타내며, private method는 클래스의 내부를 정리하고 클래스의 인터페이스를 더욱 간결하게 만듭니다.

== About static vs instance methods

* Static method는 Class method라고도 불린다.
클래스 내부에 정의하지만, 인스턴스에는 속하지 않는다는 특징이 있다.

가장 큰 차이점은 객체 생성 여부

* Static method는 클래스 변수와 마찬가지로
객체를 생성하지 않고 클래스명.메서드명으로 호출 가능하다.

*Instance method는 Static method와는 달리, 반드시 객체를 생성한 후에 호출 가능하다.
즉, Instance method는 인스턴스가 반드시 존재해야만 사용할 수 있다.

[source, java]
----
static일때

static int find(int[] arr, int val)
  requires: val occurs in arr
  effects:  returns index i such that arr[i] = val

인스턴스일때

int find(int val)
  requires: val occurs in *this array*
  effects:  returns index i such that *the value at index i in this array*
              is val
----

* 인스턴스 일때는 해당 클래스의 ``this``와 val의 값을 계산 +
ex) this.val += val;

== 정리

* specification은 구현자와 클라이언트 간 코드와 코드 간의 중요한 방화벽 역할을 합니다. 이를 통해 모듈의 소스 코드를 보지 않고도 클라이언트는 모듈을 사용하는 코드를 작성하고, 구현자는 구현 코드를 작성할수 있습니다.

* 선언적 명세가 실제로 가장 유용합니다. precondition은 명세를 약화시키는 요소로 클라이언트에게 어려움을 줄 수 있지만, 현명하게 적용하면 소프트웨어 디자이너에게 필요한 가정을 할 수 있는 중요한 도구입니다.

* 항상 목표는 소프트웨어를 다음과 같이 디자인하는 것

. Safe from bugs
.. 명세가 없으면 프로그램의 아주 작은 변경이 전체 프로그램을 무너뜨릴수 있다.
. Easy to understand
.. 잘 작성된 선언적 명세는 클라이언트가 코드를 읽거나 이해하지 않아도 됩니다.
. Ready for change
.. 적절하게 약한 명세는 구현자에게 자유를 주고, 적절하게 강한 명세는 클라이언트 에게 자유를 줍니다. 심지어 명세 자체를 변경하게 더욱 강하게 할수 있으므로 사용되는 모든곳을 검토할 필요가 없습니다.(precondition 및 postcondition 강화)