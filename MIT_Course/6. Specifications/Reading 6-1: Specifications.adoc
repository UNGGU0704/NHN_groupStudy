= Reading 6 : Specifications
Reference by <http://web.mit.edu/6.005/www/fa15/classes/06-specifications/specs/>
v1.0, 2023-09-19


== **``Specifications``**?
** 소프트웨어가 어떻게 동작하는지, 어떤 조건을 만족해야 하는지를 정의

예를들어 당신이 은행 애플리케이션을 개발하고 있다고 가정하고 +
이 애플리케이션은 사용자가 계좌에서 돈을 인출할 때 올바른 금액을 제공한다. +
여기서 `Specification` 작성할 수 있다.

* **``Specification``**

** **함수 이름** : withdrawMoney
** **입력(``precondition``)**
*** 계좌 잔고가 요청된 인출 금액보다 크거나 같아야 한다.
*** 인출 금액은 0보다 커야 한다.

** **출력 (``postcondition``)**
*** 인출이 성공하면 계좌 잔고는 인출 금액만큼 감소합니다.
*** 인출이 실패하면 계좌 잔고는 변경되지 않아야 합니다.

== 목표

. precondition, postcondition에 대해 이해하고 올바른 specification 작성

. specification에 기반한 테스트 케이스 작성

. Java에서 확인될 수 있는 예외와 확인되지 않을 수 있는 예외의 차이를 이해

. 어떻게 예외를 특별한 결과에서 사용하는지 이해

== 왜 specifications이냐?

명세는 다음과 같은 이점이 존재하기 때문

. 인터페이스 간에 발생하는 오해로 인한 심각한 버그 예방
** **인터페이스**? 두 모듈 사이의 상호 작용

. 클라이언트의 입장에서 코드 읽는 번거로움을 줄였다
** **클라이언트**? 코드나 모듈을 사용하는 쪽
. 코드 단편에 대한 이해를 쉽게 한다

=== Java의 BigInteger 클래스에서 하나의 클래스를 예로 든다

* BigInteger클래스는 정수를 표현하는 데 사용되며 int와 같은 기본 자료형의 크기 제한 없이 아주 큰 정수를 다룰 수 있다


[source, java]
----
//Specification from API documentation
public BigInteger add(BigInteger val)

Parameters:
[val]- BigInteger에 추가할 값
Returns:
this+val
----

* BigInteger객체(``this``)와 주어진 BigInteger 객체(``val``)를 더한 결과를 반환

[source, java]
----
// 메서드 구현(Java 8 source)
if (val.signum == 0)
    return this;
if (signum == 0)
    return val;
if (val.signum == signum)
    return new BigInteger(add(mag, val.mag), signum);

int cmp = compareMagnitude(val);
if (cmp == 0)
    return ZERO;
int[] resultMag = (cmp > 0 ? subtract(mag, val.mag)
                   : subtract(val.mag, mag));
resultMag = trustedStripLeadingZeroInts(resultMag);

return new BigInteger(resultMag, cmp == signum ? 1 : -1);
----

. 만약 ``val``이 0이라면 현재 BigInteger객체 (``this``)를 그대로 반환

. 만약 현재 BigInteger(``this``)가 0이라면 주어진 ``val``을 그대로 반환

. ``val``과 현재 BigInteger 객체(``this``)의 부호가 같다면, 두 BigInteger값을 더하여 새로운 BigInteger 객체를 생성하고 반환

. 그외의 경우, BigInteger 값들을 비교하고 적절한 연산을 수행하여 결과를 반환

* **코드와 specification의 중요성과 이점**
** **specification(명세서)의 중요성**: 코드의 사용자에게 메서드 또는 클래스의 동작을 설명하는 문서이다.
** 명세서는 코드를 더 이해하기 쉽게 만들어주며, 사용자에게 어떻게 메서드를 사용해야 하는지 안내한다
** 코드와 명세서는 클라이언트와 구현자 간의 계약 역할을 하며, 서로간의 독립성을 유지하고 코드의 유지보수와 최적화를 용이하게 한다.
** 이를 통해 코드의 가독성과 유연성을 높이며 개발자에게 자유를 부여하고 효율적인 구현을 가능하게함

image::http://web.mit.edu/6.005/www/fa15/classes/06-specifications/figures/firewall.png[]

== 동작의 동등성

[source, java]
----
static int findFirst(int[] arr, int val) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == val) return i;
    }
    return arr.length;
}

static int findLast(int[] arr, int val) {
    for (int i = arr.length -1 ; i >= 0; i--) {
        if (arr[i] == val) return i;
    }
    return -1;
}
----

* 두 메서드는 비슷한 역할을 가지지만 약간 다르게 동작한다.
. `findFirst` 메서드는 배열``arr``에서 값``val``을 처음 발견한 인덱스를 반환한다. 만약 ``val``을 발견하지 못하면 배열의 길이를 반환한다.
. `findLast` 메서드는 배열 ``arr``에서 값``val``을 마지막으로 발견한 인덱스를 반환한다, 만약``val``을 발견하지 못하면 -1을 반환한다.

* ``val``이 배열에서 딱 하나만 존재할 때, 두 메서드는 똑같은 인덱스 반환

* 두 메서드는 어떤 것을 사용해도 클라이언트에게 문제가 없을 수도 있다. 하지만 두 메서드간의 교체가 가능하려면 어떤 동작을 하는지 명시하는 specification 필요

다음과 같이 정의 가능

[source, java]
----
static int find(int[] arr, int val)
    requires: val이 배열 arr에서 정확히 한 번 발견됨
    effects: val을 찾아서 해당 인덱스 i를 반환하며, arr[i] = val
----
* 즉 클라이언트가 메서드를 호출할 때 ``val``이 배열에서 정확히 한 번 발견되는 것을 전대로 하며, 해당 인덱스를 반환하고 `arr[i]` 가 ``val``과 같아야 한다는 것을 명시적으로 정의한 명세서이다. +
이러한 sepcification이 있다면 두 메서드를 교체해도 클라이언트의 기대와 일치하는 동작 가능

== Specification의 구조

* specification의 구성
** 사전 조건(precondition): ``requires``라는 키워드로 표시
*** 입력 조건
*** 함수가 call되기 전에 무엇이 참이 되어야 하는지 나타내는 문장
*** 함수가 호출되기 전에 참이 되어야만 하는 조건을 말하는 문장

** 사후 조건(postcondition): ``effects``라는 키워드로 표시
*** 출력 조건
*** 함수가 기능하고 난 뒤 무엇이 참이어야 하는지 나타내는 문장
*** 함수가 실행되고 나서 무엇이 참이 되어야 하는지 말하는 문장

* 이 구조는 ``logical implication``: 사전조건이 메서드 호출시 충족되면 메서드가 완료될때 사후 조건이 반드시 충족된다.
** precondition이 충족되지 않는 경우 메서드 구현은 예외를 던지거나 임의의 결과를 반환할수 있어야 한다

image::http://web.mit.edu/6.005/www/fa15/classes/06-specifications/figures/firewall-implies.png[]

image::http://web.mit.edu/6.005/www/fa15/classes/06-specifications/figures/firewall-unsat.png[]

== 자바에서의 specifications

* static type declarations은 precondtion과 postcondition의 일부로 간주되며, 컴파일러에 의해 자동으로 확인된다
* 타입으로 작성할 수 없는 부분은 메서드 앞에 주석으로 설명

* JavaDoc: 매개변수는 ``@param``절로 설명되고 결과는 ``@return``및 ``@throw``절로 설명된다

[source, java]
----
static int find(int[] arr, int val)
  requires: val occurs exactly once in arr
  effects:  returns index i such that arr[i] = val

... Java식으로 변환 하면 ...

/**
 * 배열에서 값을 찾습니다.
 * @param arr 검색할 배열, val이 arr에 정확히 한 번 나타난다는 것을 요구
 * @param val 검색할 값
 * @return arr[i] = val을 만족하는 인덱스 i를 반환
 */
static int find(int[] arr, int val)
----

* Java API 문서는 Java 표준 라이브러리 소스 코드의 Javadoc 주석에서 생성됩니다.

== Null references

* Java에서 객체 및 배열에 대한 reference는 null이라는 특별한 값을 가질수 있다. +
이것은 참조가 어떠한 객체를 가리키지 않음을 의미이며, Java타입 시스템에서 예외적인 부분

* Primitive type은 Null이 될수 없습니다.
** primitive type 변수에는 null 값을 할당할수 없으며, 컴파일 타임에 static errors로 거부된다.

[source, java]
----
int size = null; // compile error
double depth = null; // compile error
----

* Reference type에는 null을 할당할 수 있다.
** 런타임에 NullPointerException이 발생할 수 있다.

[source, java]
----
String name = null;
int[] points = null;
----

. null은 빈 문자열 또는 빈 배열과 다릅니다.
** 빈 문자열 ("")이나 빈 배열은 메서드를 호출하고 필드에 접근할 수 있다. +
빈 배열 또는 빈 문자열의 길이는 0입니다. 그러나 null을 가리키는 문자열 변수의 길이를 호출하면 NullPointerException이 발생합니다.

[source, java]
----
name.length()   // throws NullPointerException  
points.length   // throws NullPointerException
----

** null 값은 문제를 일으키고 안전하지 않기 때문에 설계 용어에서 가능한 한 제거하는 것이 좋습니다.

** Java 프로그래밍에서 null 값을 매개변수 및 반환 값으로 암묵적으로 허용하지 않는다.

** 모든 메서드는 객체 또는 배열 매개변수에 대한 precondition으로 non-null이어야 함 또한  반환 값이 non-null임이 암묵적임

** null을 받거나 반환하는 경우에는 명시적으로 명시해야 함 (null은 피하자)

* Java에는 null을 type declaration에서 금지하는 확장 기능 존재

[source, java]
----
static boolean addAll(@NonNull List<T> list1, @NonNull List<T> list2)
----

* Google은 Guava 회사의 주요 Java 라이브러리인 Guava에서 null에 대한 논의를 했으며 다음과 같다

** 95%의 컬렉션에는 null 값을 포함시키지 않을것으로 의도되어 있다.
** 이러한 컬렉션에서 null 값을 만났을 때는 예외를 발생시키는 것이 개발자에게 더 도움이 된다.
** 구글의 null의 다의성에 대한 문제 지적
*** null 반환값의 의미하는 바가 명확하지 않다
*** 예를들어 `Map.get(key)` 을 사용할 때 반환값이 null일 수도 있고 지정된 키가 맵에 없을 수도 있다.
*** null은 실패, 성공 또는 거의 모든 것을 나타낼 수 있으므로 코드 동작 예측이 어렵다, 따라서 모호성을 줄이기 위해 null 대신 대안 사용 권장

== specification이 말하는 것

* 메서드 ``specificaion``는 매개변수와 반환값에 대한 설명은 가능하지만, 메서드 내부의 지역 변수나 클래스의 private field에 대해서는 언급하면 안 됩니다.

image::http://web.mit.edu/6.005/www/fa15/classes/06-specifications/figures/firewall-talk.png[]

== Testing and sepcifications

. Black Box Test: specification만 고려해 테스트 케이스 선택하는 방식, 이경우 test case는 메서드 함수의 내부 구현을 고려하지 않고 specification에 따라 선택

. Glass Box Test: 실제 구현 내용을 고려하여 test case를 선택하는 방식, 코드 내부 동작을 이해하고 그에 따라 test case 선택

** 그러나 glass box test라 하더라도 test case는 ``specification``을 준수 해야한다.
*** 구현이 명세에서 요구하는 것보다 강력한 보장을 제공할 수도 있으며, 명세에서 정의되지 않은 특정 동작을 갖리 수도 있기 때문이다.

[source, java]
----
static int find(int[] arr, int val)
  requires: val occurs in arr
  effects:  returns index i such that arr[i] = val


  int[] array = new int[] { 7, 7, 7 };
assertEquals(0, find(array, 7));  // bad test case: violates the spec
assertEquals(7, array[find(array, 7)]);  // correct
----

* find 메서드의 ``specification``이 ``val``이 항상 배열에서 가장 낮은 인덱스를 반환하더라도, test case는 이 특정 동작을 가정해서는 안 됩니다.

* ``glass box test``란 구현 내부를 이해하면서 구현의 다른 부분을 테스트 하는것을 의미
** 하지만 명세는 따라야 합니다
** 구현의 다른 부분을 테스트하면서도 ``specification``을 위반하지 않는 test case를 찾는 것이 목표

=== Testing units

[source, java]
----
/** @return the contents of the web page downloaded from url */
public static String getWebPage(URL url) { ... }

/** @return the words in string s, in the order they appear,
 *          where a word is a contiguous sequence of
 *          non-whitespace and non-punctuation characters */
public static List<String> extractWords(String s) { ... }

/** @return an index mapping a word to the set of URLs
 *          containing that word, for all webpages in the input set */
public static Map<String, Set<URL>> makeIndex(Set<URL> urls) { 
    ...
    calls getWebPage and extractWords
    ...
} 
----

* **unit testing**: 각 모듈을 독립적으로 테스트
** 각 테스트는 해당 모듈의 specification에 집중

* **integration testing**: 여러 모듈을 결합하여 테스트
** 각 모듈이 다른 모듈과의 호환성을 가지고 있는지 확인
** 통합 테스트는 단위 테스트를 대체하지 못하며, 모든 모듈을 독립적으로 테스트 해야한다.
** 그렇지 않다면, 버그가 숨어 있을 수 있고, 프로그램 다른 부분에서 문제가 발생할 수 있다.

== 객체를 변경하는(mutating) 메서드의 specifications

[source, java]
----
static boolean addAll(List<T> list1, List<T> list2)
    requires: list1 != list2
    effects: list2의 요소를 끝에 추가하여 list 1을 수정합니다. 호출의 결과로 list1이 변경되면 true 반환
----

* ``effects``섹션으로 이 부분에서 메서드의 ``side-effect``및 반환 값으로 postcondition 설명

** 여기서 ``side-effect``란 메서드 호출로 인해 메서드 외부에 영향을 미치는 것을 의미 +
즉 메서드가 호출되면 메서드 내부에서 변수나 데이터를 변경하거나, 다른 동작을 수행하여 시스템 전체에 영향을 주는 것을 말한다.
** 예를들어 "addAll"메서드의 경우, 메서드가 호출되면 list1이라는 리스트에 list2의 요소가 추가되는 것이 부작용이다. +
이것은 메서드 외부에서 list1의 상태가 변경되었음을 의미

* ``requires``섹션으로 이부분에서 메서드 호출 전에 충족 되어야 하는 precondition을 설명한다.
** list1과 list2는 서로 다른 객체여야 한다는 조건을 명시하고 있습니다. 
** 즉 같은 리스트를 자기 자신에게 추가하려고 할 때는 정의되지 않은 동작으로 간주
** 또한, 객체 참조가 null이 아닌 유효한 객체여야 한다는 암묵적인 precondition 언급, 이는 대부분의 경우 해당하기에 별도로 명시 하지 않음

[source, java]
----
static void sort(List<String> lst)
  requires: nothing
  effects:  puts lst in sorted order, i.e. lst[i] <= lst[j]
              for all 0 <= i < j < lst.size()

static List<String> toLowerCase(List<String> lst)
  requires: nothing
  effects:  returns a new list t where t[i] = lst[i].toLowerCase()
----

* 객체 변경이 specification에 명시적으로 언급되지 않는 한 변경이 허용되지 않는 관례를 사용
* "toLowerCase"메서드와 같이 입력 객체를 변경하지 않는 경우, 변경에 대한 명세가 없다면 변경이 발생하지 않음을 가정합니다.

* 즉 객체를 변경하는 메서드의 명세는 메서드의 동작, 부작용, precondition, postcondition을 설명, 변경이 허용되는 경우를 제외하고는 일반적으로 변경이 허용되지 않는다고 가정