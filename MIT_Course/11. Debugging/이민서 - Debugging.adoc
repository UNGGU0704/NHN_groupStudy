= Reading 11: Debugging
Reference by <http://web.mit.edu/6.005/www/fa15/classes/11-debugging/>
v1.0, 2023-10-03

.Objectives
* 전체 시스템을 통합하거나 배포된 후 사용자로부터 버그가 발견된 경우, 이 경우 특정 모듈로 버그를 지역화 하기 어려우며, 이러한 상황에 대비해 보다 효과적인 디버깅을 위한 체계적인 전략 제한할 수 있다.

== Reproduce the Bug(버그를 재현하기)

* 먼저 실패를 일으키는 작고 반복 가능한 test case를 찾는다. 버그가 Regression testing으로 발견되었다며, 이미 test suite에 실패하는 test case가 있다. 만약 사용자가 버그를 신고했다면, 해당 버그를 재현하는것은 노력이 필요하다, GUI 및 멀티스레드 프로그래밍의 경우는 일관된 버그 재현이 어렵다.

* 그래도 test case를 작고 반복 가능하게 만드는것이 좋다. 버그를 찾고 고치는데 반복적으로 실행해야 하기 때문이다. 또한 수정후에 해당 test case를 regression testing suite에 추가하더라도 버그가 다시 생기지 않도록 해야한다, 

* 다음과 같은 함수를 작성했다 가정

[source, java]
----
/**
 * 문자열에서 가장 일반적인 단어 찾기.
 * @param text 문자열에는 영단어가 0개 이상 포함되며, 영단어는 알파벳 또는 숫자 문자로 둘러싸인 문자열입니다.
 * @return 텍스트에서 최대 빈도로 발생하는 단어, 알파벳의 대소문자는 무시
 */
public static String mostCommonWord(String text) {
    ...
}
----

* 사용자가 쉐익스피어의 모든 대본을 메서드에 전달한다면, 영어 단어인 "the"나 "a"대신 예상치 못한 예를들어"e"가 반환됩니다.

* 쉐익스피어의 연극은 100,000줄 이상에 800,000단어가 포함되어 있으므로, 이러한 입력은 프린트 디버깅과, 중단점 디버깅과 같은 일반적인 방법으로는 디버그하는데 어려우며, 매우 복잡하다.
** 버그를 찾을땐 먼저 관리 가능한 크기의 오류 입력으로 줄이는 작업부터 하는것이 쉽다.

* 작은 test case를 찾았으면 해당 케이스를 사용해 버그를 찾고 수정한 다음 원래의 오류 입력으로 돌아가서 동일한 버그를 수정합니다.

== Understand the Location and Cause of the Bug(버그의 위치와 원인 이해)

.버그의 위치와 원인을 이해하기위한 과학적인 방법

. **``Study the data``**: 버그를 일으키는 테스트 입력 및 부정확한 결과, 실패한 assertion 그리고 stack trace를 살펴봅니다.

. **``Hypothesize``**: 데이터와 일관성 있는 가설 설정. 이 가설은 버그가 어디에 있을 수 있는지 또는 없을 수 있는지에 대한 것입니다. 처음엔 이 가설을 설정하는게 일반적으로 좋습니다.

. **``Experiment``**: 가설을 테스트할 실험을 계획. 실험은 처음에는 정보를 수집하지만, 시스템에 최소한의 영향을 미치도록하는 것이 좋다.

. **``Repeat``**: 실험에서 수집한 데이터를 기존에 알고 있던 정보에 추가하고 새로운 가설을 세우는 과정을 반복

* monstCommonWord()예제를 통해 살펴본다. 3가지 helper method를 포함한 함수 사용

[source, java]
----
/**
 * 문자열에서 가장 일반적인 단어 찾기.
 * @param text 알파벳 이외의 문자로 둘러싸인 알파벳 문자열을 포함하는 문자열,
 *     단어는 알파벳 문자 사이의 문자열입니다.
 * @return 텍스트에서 최대 빈도로 발생하는 단어, 알파벳의 대소문자를 무시합니다.
 */
public static String mostCommonWord(String text) {
    ... words = splitIntoWords(text); ...
    ... frequencies = countOccurrences(words); ...
    ... winner = findMostCommon(frequencies); ...
    ... return winner;
}

/** 문자열을 단어로 분할하는 메서드 ... */
private static List<String> splitIntoWords(String text) {
    ...
}

/** 각 단어가 얼마나 자주 나타나는지 세는 메서드 ... */
private static Map<String,Integer> countOccurrences(List<String> words) {
    ...
}

/** 가장 빈도수가 높은 단어를 찾는 메서드 ... */
private static String findMostCommon(Map<String,Integer> frequencies) {
    ...
}
----

Study the Data::
* 예외에서 얻은 stack trace는 중요한 데이터 형태 중 하나입니다. stack trace를 읽는 연습을 하면, 어디에 버그가 있을 수 있고, 어떤 종류의 버그인지에 대한 엄청난 양의 정보를 제공

** 작은 test case를 분리하는 과정은 이전에 없던 데이터를 얻을 수도 있습니다. 하나의 버그에 두가지 test case가 있을 수 있으며, 이 경우 하나는 성공하고 하나는 실패.
** 예를 들어, "mostCommonWords("c c, b")"가 작동하지 않을 수 있지만 "mostCommonWords("c c b")"는 정상적으로 동작할 수 있습니다.

Hypothesize::
* 프로그램의 모듈 또는 알고리즘 단계로 생각하고 한 번에 전체 프로그램 섹션을 배제하려고 노력하는 것이 도움이 됩니다.

image::http://web.mit.edu/6.005/www/fa15/classes/11-debugging/figures/dataflow.png[]

* 예를 들어, 만약 버그가 발생한 증상이 countOccurrences() 함수에서 발생하는 예외라면, 그 함수를 포함한 그 이후의 부분은 배제할 수 있습니다. 그리고 여기서는 countOccurrences() 함수에 원인이 있을 것으로 가설을 세울 수 있습니다.

* 그 다음, 더 구체적으로 버그가 어떤 부분에서 발생하는지에 대한 가설을 세우게 됩니다. 예를 들어, splitIntoWords() 함수에서 버그가 발생하고 그 결과가 countOccurrences() 함수에서 예외를 일으킨다고 가설을 세울 수 있습니다. 그런 다음 이 가설을 실험을 통해 검증합니다. 만약 가설이 참이라면, countOccurrences() 함수가 문제의 원인이 아니라는 것을 확인할 수 있고, 가설이 거짓이라면 splitIntoWords() 함수를 배제하게 됩니다.

Experiment::
* 좋은 실험은 시스템을 크게 방해하지 않고 조용하게 관찰하는 것

. 다른 test case 실행: 위에서 언급한 test case 축소 과정은 실험으로서의 test case 사용

. 실행 중인 프로그램에 print statement 이나 assertion을 삽입하여 내부 상태 확인

. 디버거를 사용해 breakpoint를 설정해 코드를 한 단계씩 실행하고 변수 및 객체의 값들을 살펴봅니다.

* 흔히 가설로 추측한 버그를 수정하려는 것은 잘못된 접근.
. 이것은 일종의 Ad-hoc 추측 및 테스트 프로그래밍으로 이어져 끔찍하고 복잡하며 이해하기 어려운 코드를 생성
.. what is ad-hoc? 특정 상황에서만 정답이 되고 일반화 될수없는 답. 그러므로 재사용 불가. 개발기간이 촉박 할때 급하게 요구사항을 맞추는데 사용, 소위 "하드코딩"이라 불리는 방법으로 코딩하여 만든 솔루션
. 당신의 수정은 실제 버그를 제거하지 않고 숨길 수 있다.

* 예를 들어, ArrayOutOfBoundsException을 받고 있다면, 먼저 무슨 일이 일어나고 있는지를 이해해야한다.

Other tips::

. Bug localization by binary search
** 디버깅은 검색 과정이며, 때로는 이진 검색을 사용해 빠르게 디버깅 가능. 
** 예를 들어, mostCommonWords 함수에서 데이터가 세 개의 도움 메서드를 통해 흐릅니다. 이진 검색을 수행하려면 이 작업 흐름을 반으로 나누고, 버그가 첫 번째 도움 메서드 호출과 두 번째 도움 메서드 호출 사이 어딘가에 있는 것으로 추측하고, 그 위치에 결과를 확인하는 프로브(중단점, 프린트 문, 또는 어설션과 같은)를 삽입할 수 있습니다. 그 실험의 답변을 기반으로 더 세분화할 수 있습니다.

. Prioritize your hypotheses
** 가설을 세울때 시스템의 각 부분이 실패할 가능성이 다르다.
** 예를 들어, 오래되고 잘 테스트된 코드는 최근에 추가된 코드보다 신뢰성이 높을 것입니다. Java 라이브러리 코드는 여러분의 코드보다 신뢰성이 높을 것입니다. Java 컴파일러 및 런타임, 운영 체제 플랫폼 및 하드웨어는 시험과 검증을 더 많이 받았기 때문에 더 신뢰성이 높을 것입니다. 이러한 하위 수준을 신뢰하고 좋은 이유가 없는 한 다른 부분을 의심하지 않아야 합니다.

. Swap components
** 모듈의 또 다른 구현이 동일한 인터페이스를 충족하고 모듈을 의심하는 경우, 대체 구현을 시도하는 실험을 수행할 수 있습니다. 
** 예를 들어, binarySearch() 구현을 의심한다면 더 간단한 linearSearch()로 대체해 볼 수 있습니다. java.util.ArrayList를 의심한다면 java.util.LinkedList로 대체할 수 있습니다. Java 런타임을 의심한다면 다른 버전의 Java에서 실행해 볼 수 있습니다. 운영 체제를 의심한다면 프로그램을 다른 운영 체제에서 실행해 볼 수 있습니다. 하드웨어를 의심한다면 다른 컴퓨터에서 실행해 볼 수 있습니다. 그러나 무결한 컴포넌트를 교체하는 데 많은 시간을 낭비할 수 있으므로 해당 컴포넌트를 의심할 충분한 이유가 없는 경우에만 시도해야 합니다.

. Make sure your source code and object code are up to date
** 리포지토리에서 최신 버전을 가져오고 모든 바이너리 파일을 삭제하고 모든 것을 다시 컴파일하는 등 소스 코드와 객체 코드를 최신 상태로 유지해야 합니다. (Eclipse에서는 Project → Clean을 통해 수행합니다.)

. Get help
** 다른 사람에게 문제를 설명하면 종종 도움이 됩니다. 그 사람이 어떤 얘기를 하는지 모르더라도 문제를 설명하면 생각이 정리되고 도움이 될 수 있습니다

. Sleep on it
** 지나치게 피곤하면 효과적인 디버거가 되기 어렵습니다

== Fix the Bug
* 버그를 찾고 그 원인을 파악한 후 버그를 해결하는 것
** 먼저 버그가 코딩 오류인지 (예: 변수 이름의 오타나 메서드 매개변수가 바뀐 것과 같은) 아니면 설계 오류인지 (예: 불충분하거나 명시되지 않은 인터페이스)를 고민해야 합니다. 설계 오류라면 설계를 다시 검토하거나 적어도 해당 실패하는 인터페이스의 다른 클라이언트를 검토하여 해당 버그에 영향을 받는지 확인해야 할 수도 있습니다.

* 마지막으로, 수정을 적용한 후에 해당 버그의 test case를 회귀 테스트에 suite에 추가하고 모든 테스트를 실행해 버그가 더이상 생기지 않고 수정되었는지 확인해야 한다.
